#!/home/gh/python/venv_py311/bin/python3
"""
HEVC to H.264 CUDA Converter (Python Wrapper)
"""

import os
import sys
import subprocess
import argparse
from pathlib import Path
from datetime import datetime
import logging

# CUDA Environment
os.environ['LD_LIBRARY_PATH'] = '/usr/local/cuda-11.8/targets/x86_64-linux/lib:' + os.environ.get('LD_LIBRARY_PATH', '')

DEFAULT_BASE_DIR = "/var/www/web1"
LOG_FILE = "/home/gh/python/logs/video_conversion_cuda.log"
TEMP_DIR = "/tmp/video_convert_cuda"

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)


def check_gpu():
    try:
        result = subprocess.run(
            ['nvidia-smi', '--query-gpu=name,memory.total,memory.used,utilization.gpu',
             '--format=csv,noheader'],
            capture_output=True, text=True, check=True
        )
        logger.info(f"GPU Status:\n{result.stdout.strip()}")
        return True
    except:
        logger.warning("‚ö†Ô∏è  nvidia-smi nicht gefunden")
        return False


def is_hevc(video_path):
    try:
        result = subprocess.run(
            ['ffprobe', '-v', 'error', '-select_streams', 'v:0',
             '-show_entries', 'stream=codec_name',
             '-of', 'default=noprint_wrappers=1:nokey=1', str(video_path)],
            capture_output=True, text=True, check=True, timeout=5
        )
        return result.stdout.strip().lower() == 'hevc'
    except:
        return False


def find_mp4_videos(base_dir, max_depth=10):
    logger.info(f"Suche nach MP4-Videos in {base_dir}...")
    videos = []
    base_path = Path(base_dir)

    if not base_path.exists():
        logger.error(f"‚ùå Verzeichnis nicht gefunden: {base_dir}")
        return []

    # Einfache rekursive Suche
    for video in base_path.rglob("*.mp4"):
        # Pr√ºfe Tiefe
        try:
            relative = video.relative_to(base_path)
            if len(relative.parts) <= max_depth:
                videos.append(video)
        except ValueError:
            continue

    logger.info(f"DEBUG: {len(videos)} MP4-Dateien gefunden")
    return videos


def convert_video_cuda(input_path, temp_dir):
    input_file = Path(input_path)
    basename = input_file.name
    temp_output = temp_dir / f"{input_file.stem}_h264.mp4"

    logger.info(f"üöÄ CUDA-Start: {basename}")

    try:
        cmd = [
            'ffmpeg', '-y', '-i', str(input_file), '-vf', 'scale=-2:2160',
            '-c:v', 'h264_nvenc', '-preset', 'fast', '-pix_fmt', 'yuv420p',
            '-movflags', '+faststart', '-c:a', 'copy', str(temp_output)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)

        if result.returncode != 0:
            logger.error(f"‚ùå CUDA-Fehler: {basename}")
            return False

        # Validierung
        probe = subprocess.run(['ffprobe', '-v', 'error', str(temp_output)],
                             capture_output=True, timeout=10)

        if probe.returncode != 0:
            logger.error(f"‚ùå Validierung fehlgeschlagen: {basename}")
            temp_output.unlink(missing_ok=True)
            return False

        # Gr√∂√üenvergleich
        old_size = input_file.stat().st_size / (1024 * 1024)
        new_size = temp_output.stat().st_size / (1024 * 1024)

        # Ersetze Original
        temp_output.replace(input_file)
        os.chmod(input_file, 0o664)

        logger.info(f"‚úÖ Erfolg: {basename} ({old_size:.1f}MB ‚Üí {new_size:.1f}MB)")
        return True

    except Exception as e:
        logger.error(f"‚ùå Fehler bei {basename}: {e}")
        temp_output.unlink(missing_ok=True)
        return False


def main():
    parser = argparse.ArgumentParser(description='HEVC zu H.264 CUDA Converter')
    parser.add_argument('base_dir', nargs='?', default=DEFAULT_BASE_DIR,
                       help=f'Basis-Verzeichnis (default: {DEFAULT_BASE_DIR})')
    parser.add_argument('--max-depth', type=int, default=10,
                       help='Maximale Verzeichnistiefe (default: 10)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Nur analysieren, keine Konvertierung')

    args = parser.parse_args()

    logger.info("=== Start Transcoding mit CUDA 11.8 ===")
    logger.info(f"Basis-Verzeichnis: {args.base_dir}")

    temp_dir = Path(TEMP_DIR)
    temp_dir.mkdir(parents=True, exist_ok=True)

    check_gpu()

    # Finde Videos
    videos = find_mp4_videos(args.base_dir, args.max_depth)

    if not videos:
        logger.error("‚ùå Keine MP4-Dateien gefunden")
        return 1

    # Analysiere Codecs
    logger.info("Analysiere Codecs...")
    hevc_videos = []
    h264_count = 0

    for i, video in enumerate(videos, 1):
        if i % 10 == 0:
            logger.info(f"DEBUG: Verarbeite Video {i}/{len(videos)}...")

        if is_hevc(video):
            hevc_videos.append(video)
            if len(hevc_videos) <= 3:
                logger.info(f"DEBUG: HEVC gefunden: {video.name}")
        else:
            h264_count += 1

    logger.info(f"Gefunden: {len(videos)} MP4-Dateien ({len(hevc_videos)} HEVC, {h264_count} H.264)")

    if not hevc_videos:
        logger.info("‚úÖ Keine HEVC-Videos zu konvertieren!")
        return 0

    if args.dry_run:
        logger.info("DRY-RUN: Konvertierung √ºbersprungen")
        for video in hevc_videos[:10]:
            logger.info(f"  - {video}")
        if len(hevc_videos) > 10:
            logger.info(f"  ... und {len(hevc_videos) - 10} weitere")
        return 0

    # Konvertierung
    logger.info(f"Starte Konvertierung von {len(hevc_videos)} HEVC-Videos...")
    success = 0
    failed = 0

    for i, video in enumerate(hevc_videos, 1):
        logger.info(f"[{i}/{len(hevc_videos)}] {video.name}")
        if convert_video_cuda(video, temp_dir):
            success += 1
        else:
            failed += 1

    # Cleanup
    import shutil
    shutil.rmtree(temp_dir, ignore_errors=True)

    logger.info(f"=== Fertig: {success} erfolgreich, {failed} Fehler ===")
    return 0 if failed == 0 else 1


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        logger.info("\n‚ö†Ô∏è  Abgebrochen")
        sys.exit(130)
    except Exception as e:
        logger.error(f"‚ùå Fehler: {e}", exc_info=True)
        sys.exit(1)
